#include "_impl/config/args.hpp"

namespace erl {

struct CLI {
  static constexpr annotations::Option option;
  static constexpr auto value = _expect_impl::Placeholder<0>{};

  using shorthand   = annotations::Shorthand;
  using description = annotations::Description;

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    constexpr static _impl::Spec spec{remove_cvref(^^T)};
    auto program_name = Program::name();
    std::string arguments{};
    for (auto argument : spec.arguments) {
      if (argument.is_optional) {
        arguments += std::format("[{}] ", argument.name);
      } else {
        arguments += std::format("{} ", argument.name);
      }
    }
    std::println("usage: {} {}", program_name, arguments);

    if (auto desc = annotation_of_type<annotations::Description>(^^T); desc) {
      std::println("\n{}", desc->data);
    }

    std::println("\nArguments:");
    for (auto argument : spec.arguments) {
      std::string constraint =
          argument.constraint.empty() ? "" : std::format("\n{:<8}requires: {}", "", argument.constraint);
      std::println("    {} -> {}{}", argument.name, argument.type, constraint);
    }

    std::println("\nOptions:");

    auto name_length = [](_impl::Option const& opt) { return opt.name.size(); };
    auto safe_max    = [&](std::span<_impl::Option const> const& opts) {
      return opts.empty() ? 0 : std::ranges::max(opts | std::views::transform(name_length));
    };
    std::size_t max_name_length = std::max(safe_max(spec.commands), safe_max(spec.options));

    auto print_option = [&](_impl::Option opt) {
      std::string params;
      bool has_constraints = false;
      for (auto argument : opt.arguments) {
        if (argument.is_optional) {
          params += std::format("[{}] ", argument.name);
        } else {
          params += std::format("{} ", argument.name);
        }
        has_constraints = !argument.constraint.empty();
      }

      std::println("    --{} {}", opt.name, params);
      std::size_t offset = max_name_length + 4 + 4;
      if (!opt.description.empty()) {
        std::println("{:<{}}{}\n", "", offset, opt.description);
      }

      if (opt.arguments.size() != 0) {
        std::println("{:<{}}Arguments:", "", offset);
        for (auto argument : opt.arguments) {
          std::string constraint =
              argument.constraint.empty()
                  ? ""
                  : std::format("\n{:<{}}requires: {}", "", offset + 8, argument.constraint);
          char const* optional = "";
          if (argument.is_optional) {
            optional = " (optional)";
          }
          std::println("{:<{}}{} -> {}{}{}",
                       "",
                       offset + 4,
                       argument.name,
                       argument.type,
                       optional,
                       constraint);
        }
      }
    };

    for (auto command : spec.commands) {
      print_option(command);
    }

    for (auto opt : spec.options) {
      print_option(opt);
    }
    std::exit(0);
  }
};

template <typename T>
T parse_args(std::vector<std::string_view> args_in) {
  return ::erl::_impl::parse_args<T>(args_in);
}
}  // namespace erl